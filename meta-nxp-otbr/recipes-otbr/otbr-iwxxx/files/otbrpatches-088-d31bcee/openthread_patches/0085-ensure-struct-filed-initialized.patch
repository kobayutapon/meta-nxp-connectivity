/*
*  Copyright (c) 2020, The OpenThread Authors.
*  Copyright 2024-2025 NXP
*  All rights reserved.
*
*  Redistribution and use in source and binary forms, with or without
*  modification, are permitted provided that the following conditions are met:
*  1. Redistributions of source code must retain the above copyright
*     notice, this list of conditions and the following disclaimer.
*  2. Redistributions in binary form must reproduce the above copyright
*     notice, this list of conditions and the following disclaimer in the
*     documentation and/or other materials provided with the distribution.
*  3. Neither the name of the copyright holder nor the
*     names of its contributors may be used to endorse or promote products
*     derived from this software without specific prior written permission.
*
*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
*  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
*  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
*  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
*  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
*  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
*  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
*  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
*  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
*  POSSIBILITY OF SUCH DAMAGE.
*/

/*
* Header for patch information.
* Description : Initialized struct in some instances in core/tcp6 and posix/udp.
* Version : v001
* Mandatory/Optional : Mandatory
* Impact if not applied : It is mandatory to achive thread 1.4 test 12.x.
*/

Upstream-Status: Backport

commit 151cf324bc8a07455188cb427286fee65381c71a
Author: Esko Dijk <EskoDijk@users.noreply.github.com>
Date:   Tue Jun 3 17:24:09 2025 +0200

    [tcp][posix] ensure struct fields are initialized (#11552)
    
    This aims to fix some instances in core/tcp6 and posix/udp where the
    complete struct was not initialized. In otPlatUdpJoinMulticastGroup
    and otPlatUdpLeaveMulticastGroup an explicit redundant setting to '0'
    is added just for clarity for people reading the code.

Upstream-Status: Inappropriate  [platform specific changes]

diff --git a/src/core/net/tcp6.cpp b/src/core/net/tcp6.cpp
index 671ad6259..204021583 100644
--- a/src/core/net/tcp6.cpp
+++ b/src/core/net/tcp6.cpp
@@ -163,6 +163,7 @@ Error Tcp::Endpoint::Connect(const SockAddr &aSockName, uint32_t aFlags)
         struct sockaddr_in6 sin6p;
 
         tp.t_flags &= ~TF_FASTOPEN;
+        ClearAllBytes(sin6p);
         memcpy(&sin6p.sin6_addr, &aSockName.mAddress, sizeof(sin6p.sin6_addr));
         sin6p.sin6_port = BigEndian::HostSwap16(aSockName.mPort);
         error           = BsdErrorToOtError(tcp6_usr_connect(&tp, &sin6p));
@@ -193,6 +194,7 @@ Error Tcp::Endpoint::SendByReference(otLinkedBuffer &aBuffer, uint32_t aFlags)
 
     if (IS_FASTOPEN(tp.t_flags))
     {
+        ClearAllBytes(sin6p);
         memcpy(&sin6p.sin6_addr, &tp.faddr, sizeof(sin6p.sin6_addr));
         sin6p.sin6_port = tp.fport;
         name            = &sin6p;
@@ -221,6 +223,7 @@ Error Tcp::Endpoint::SendByExtension(size_t aNumBytes, uint32_t aFlags)
 
     if (IS_FASTOPEN(tp.t_flags))
     {
+        ClearAllBytes(sin6p);
         memcpy(&sin6p.sin6_addr, &tp.faddr, sizeof(sin6p.sin6_addr));
         sin6p.sin6_port = tp.fport;
         name            = &sin6p;
diff --git a/src/posix/platform/udp.cpp b/src/posix/platform/udp.cpp
index 5b736e52a..46cb4779e 100644
--- a/src/posix/platform/udp.cpp
+++ b/src/posix/platform/udp.cpp
@@ -463,7 +463,7 @@ otError otPlatUdpJoinMulticastGroup(otUdpSocket        *aUdpSocket,
                                     const otIp6Address *aAddress)
 {
     otError          error = OT_ERROR_NONE;
-    struct ipv6_mreq mreq;
+    struct ipv6_mreq mreq  = {};
     int              fd;
 
     VerifyOrExit(aUdpSocket->mHandle != nullptr, error = OT_ERROR_INVALID_ARGS);
@@ -474,6 +474,7 @@ otError otPlatUdpJoinMulticastGroup(otUdpSocket        *aUdpSocket,
     switch (aNetifIdentifier)
     {
     case OT_NETIF_UNSPECIFIED:
+        mreq.ipv6mr_interface = 0; // Explicitly set to 0 to clarify intention.
         break;
     case OT_NETIF_THREAD_HOST:
         mreq.ipv6mr_interface = gNetifIndex;
@@ -506,7 +507,7 @@ otError otPlatUdpLeaveMulticastGroup(otUdpSocket        *aUdpSocket,
                                      const otIp6Address *aAddress)
 {
     otError          error = OT_ERROR_NONE;
-    struct ipv6_mreq mreq;
+    struct ipv6_mreq mreq  = {};
     int              fd;
 
     VerifyOrExit(aUdpSocket->mHandle != nullptr, error = OT_ERROR_INVALID_ARGS);
@@ -517,6 +518,7 @@ otError otPlatUdpLeaveMulticastGroup(otUdpSocket        *aUdpSocket,
     switch (aNetifIdentifier)
     {
     case OT_NETIF_UNSPECIFIED:
+        mreq.ipv6mr_interface = 0; // Explicitly set to 0 to clarify intention.
         break;
     case OT_NETIF_THREAD_HOST:
         mreq.ipv6mr_interface = gNetifIndex;
