/*
*  Copyright (c) 2020, The OpenThread Authors.
*  Copyright 2023-2025 NXP
*  All rights reserved.
*
*  Redistribution and use in source and binary forms, with or without
*  modification, are permitted provided that the following conditions are met:
*  1. Redistributions of source code must retain the above copyright
*     notice, this list of conditions and the following disclaimer.
*  2. Redistributions in binary form must reproduce the above copyright
*     notice, this list of conditions and the following disclaimer in the
*     documentation and/or other materials provided with the distribution.
*  3. Neither the name of the copyright holder nor the
*     names of its contributors may be used to endorse or promote products
*     derived from this software without specific prior written permission.
*
*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
*  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
*  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
*  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
*  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
*  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
*  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
*  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
*  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
*  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
*  POSSIBILITY OF SUCH DAMAGE.
*/

/*
* Header for patch information.
* Description           : Sent TCP message to host if endpoint/listener not intialized by openthread TCP stack.
* Version               : v001
* Mandatory/Optional    : Mandatory
* Impact if not applied : iperf tool not works.
*/

Upstream-Status: Inappropriate [platform specific changes]

diff --git a/src/core/net/ip6.cpp b/src/core/net/ip6.cpp
index c8b75c8a7..53360490b 100644
--- a/src/core/net/ip6.cpp
+++ b/src/core/net/ip6.cpp
@@ -35,6 +35,7 @@
 
 #include "instance/instance.hpp"
 
+bool sentToHost = false;
 using IcmpType = ot::Ip6::Icmp::Header::Type;
 
 static const IcmpType kForwardIcmpTypes[] = {
@@ -977,11 +978,17 @@ Error Ip6::PassToHost(OwnedPtr<Message> &aMessagePtr,
         }
 
 #if OPENTHREAD_CONFIG_TCP_ENABLE
-        // Do not pass TCP message to avoid dual processing from both
-        // OpenThread and POSIX TCP stacks.
+        // Pass TCP message to POSIX stack if endpoint is not initialized
+        // in Openthread TCP stacks.
         case kProtoTcp:
-            error = kErrorNoRoute;
-            ExitNow();
+            error = mTcp.is_endpoint_initialized(aHeader,*aMessagePtr);
+            if (error != kErrorNone )
+            {
+                ExitNow();
+            }
+            sentToHost = true;
+            LogInfo("TCP packet will send to Host due to TCP endpoint is not initialized");
+            break;
 #endif
 
         default:
@@ -1181,6 +1188,7 @@ Error Ip6::HandleDatagram(OwnedPtr<Message> aMessagePtr, bool aIsReassembled)
     bool    forwardHost;
     uint8_t nextHeader;
 
+    sentToHost = false;
     SuccessOrExit(error = header.ParseFrom(*aMessagePtr));
 
     if (!aMessagePtr->IsOriginHostTrusted())
@@ -1226,7 +1234,7 @@ Error Ip6::HandleDatagram(OwnedPtr<Message> aMessagePtr, bool aIsReassembled)
                            (receive || forwardThread) ? kCopyMessageToUse : kTakeMessageCustody);
     }
 
-    if (receive)
+    if (receive && (sentToHost == false)) //only proceed by openthread TCP stack if TCP message not sent to Host for avoid dual processing.
     {
         error = Receive(header, aMessagePtr, nextHeader, forwardThread ? kCopyMessageToUse : kTakeMessageCustody);
     }
diff --git a/src/core/net/tcp6.cpp b/src/core/net/tcp6.cpp
index 204021583..f2ba0c7b9 100644
--- a/src/core/net/tcp6.cpp
+++ b/src/core/net/tcp6.cpp
@@ -1146,4 +1146,38 @@ uint16_t tcplp_sys_hostswap16(uint16_t aHostPort) { return BigEndian::HostSwap16
 uint32_t tcplp_sys_hostswap32(uint32_t aHostPort) { return BigEndian::HostSwap32(aHostPort); }
 }
 
+Error Tcp::is_endpoint_initialized(const ot::Ip6::Header &aHeader, Message &aMessage)
+{
+    Error             error = kErrorNone;
+    MessageInfo       messageInfo;
+    Listener *listener;
+    Endpoint *endpoint;
+
+    uint32_t header[15];
+    uint8_t  headerSize;
+    struct tcphdr  *tcpHeader;
+
+    SuccessOrExit(error = aMessage.Read(aMessage.GetOffset() + offsetof(struct tcphdr, th_off_x2), headerSize));
+    headerSize = static_cast<uint8_t>((headerSize >> TH_OFF_SHIFT) << 2);
+
+    SuccessOrExit(error = aMessage.Read(aMessage.GetOffset(), &header[0], headerSize));
+
+    tcpHeader = reinterpret_cast<struct tcphdr *>(&header[0]);
+
+    messageInfo.Clear();
+    messageInfo.SetPeerAddr(aHeader.GetSource());
+    messageInfo.SetSockAddr(aHeader.GetDestination());
+    messageInfo.mPeerPort = BigEndian::HostSwap16(tcpHeader->th_sport);
+    messageInfo.mSockPort = BigEndian::HostSwap16(tcpHeader->th_dport);
+
+    endpoint = mEndpoints.FindMatching(messageInfo);
+    listener = mListeners.FindMatching(messageInfo);
+    if ((listener != nullptr) || (endpoint != nullptr))
+    {
+       error = kErrorNoRoute;
+    }
+
+exit:
+    return error;
+}
 #endif // OPENTHREAD_CONFIG_TCP_ENABLE
diff --git a/src/core/net/tcp6.hpp b/src/core/net/tcp6.hpp
index 39733b9c4..793098be8 100644
--- a/src/core/net/tcp6.hpp
+++ b/src/core/net/tcp6.hpp
@@ -640,6 +640,7 @@ public:
      */
     bool IsInitialized(const Listener &aListener) const { return mListeners.Contains(aListener); }
 
+    Error is_endpoint_initialized(const ot::Ip6::Header &aHeader, Message &aMessage);
 private:
     enum
     {
